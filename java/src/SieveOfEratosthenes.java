import java.util.ArrayList;
import java.util.List;

/**
 * При использовании алгоритма решета Эратосфена для нахождения всех простых чисел до заданного числа используется
 * специальная структура данных - решето.
 * <p>
 * Решето представляет собой массив или список чисел, начиная с 2 (первого простого числа). Изначально все числа
 * помечаются как простые. Затем с помощью алгоритма последовательно вычеркиваются все кратные числа для каждого
 * простого числа. После выполнения алгоритма останутся только простые числа, которые остались не вычеркнутыми.
 * <p>
 * Например, если мы хотим найти все простые числа до 30, то мы создадим массив из чисел от 2 до 30 и пометим их как
 * простые. Затем мы последовательно вычеркиваем все кратные числа 2 (4, 6, 8, 10 и т.д.), затем все кратные числа 3
 * (9, 15, 21 и т.д.), затем все кратные числа 5 (25) и т.д. В результате получим массив, в котором останутся только
 * простые числа: 2, 3, 5, 7, 11, 13, 17, 19, 23 и 29.
 * <p>
 * Использование решета позволяет значительно ускорить поиск простых чисел, поскольку не требуется проверять каждое
 * число на простоту. Вместо этого мы можем последовательно вычеркивать кратные числа для каждого простого числа и
 * таким образом находить все простые числа до заданного числа.
 */
public class SieveOfEratosthenes {
    public static List<Integer> findPrimes(int n) {
        List<Integer> primes = new ArrayList<>();
        boolean[] isPrime = new boolean[n + 1];
        for (int i = 2; i <= n; i++) {
            isPrime[i] = true;
        }
        /*
          Когда мы доказываем, что число является простым,
          мы проверяем только те числа (ищем множители для этого числа),
          которые меньше или равны корню из этого числа.
          Это связано с тем, что если бы существовал множитель больше корня из числа,
          то он был бы парой с другим множителем, меньшим корня из числа,
          и мы уже бы проверили это число.

          Это означает, что если число n не является простым,
          то оно может быть представлено как произведение двух меньших чисел,
          и любой множитель, который больше корня из n, должен иметь пару,
          которая меньше или равна корню из n.
         */
        for (int i = 2; i * i <= n; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= n; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        for (int i = 2; i <= n; i++) {
            if (isPrime[i]) {
                primes.add(i);
            }
        }

        return primes;
    }

    public static int countPrimes(int n) {
        if (n == 0) return 0;
        boolean[] isPrime = new boolean[n + 1];
        for (int i = 2; i < n; i++) {
            isPrime[i] = true;
        }

        for (int i = 2; i * i < n; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= n; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        int count = 0;
        for (boolean b : isPrime) {
            if (b) {
                count++;
            }
        }
        return count;
    }

    public static void main(String[] args) {
        List<Integer> primes = findPrimes(100);
        for (int prime : primes) {
            System.out.println(prime);
        }
        System.out.println(countPrimes(3));
    }
}